require ast/block_node
require declaration
require types/function_type
require types/type_factory
require types/type_error
require types/primitive_type
require tables/symbol_table
require syntax_exception
require cfg/cfg_node
require instructions/instruction
require instructions/register
require minilang_compiler

constructor Function(line, id, return_type, body, parameters, declarations)

    :show
        "<Function " + id + " " + line + " " + typ + "\n\t" + parameters + " " + declarations  + "\n\t" + body  + ">"
    end

    input_types = parameters.map(x -> x.typ)
    typ = FunctionType(input_types, return_type)

    :typecheck(id_map, struct_map)
        # bind local variables in the id_map
        for i = 0; i < parameters.length!(); i++
            id_map[parameters[i].id] = parameters[i]
        end
        for i = 0; i < declarations.length!(); i++
            id_map[declarations[i].id] = declarations[i]
        end
        symbol_table = SymbolTable(id_map, typ)
        if return_type != primitive_type("void") && return_equivalence? (body).negate()
            print("Function "+id+" is not void and does not return in all cases!")
            primitive_type("error")
        end
        result = body.typecheck(symbol_table, struct_map)
    end

    :copy
        this
    end

    :emit_llvm
        llvm = "define " + return_type + " @" + id + "("
        param_registers = []
        for i = 0; i < parameters.length(); i++
            if i != 0
                llvm = llvm + ", "
            end
            param_registers[i] = VirtualRegister(parameters[i].typ, "_P_"+parameters[i].id, "parameters")
            llvm = llvm + parameters[i].typ + " " + param_registers[i].emit_llvm()
        end
        llvm = llvm + ")\n{"
        function_entry_cfg = CFGNode()
        function_entry_cfg.sealed = true
        function_exit_cfg = CFGNode()
        if stack_based?()
            # Emit the stack if we are using it
            for i = 0; i < parameters.length!(); i++
                local_register = VirtualRegister(parameters[i].typ, parameters[i].id, "stack")
                function_entry_cfg.add_instruction(Instruction("Allocation", [], [local_register], parameters[i].typ))
                function_entry_cfg.add_instruction(Instruction("Store", [param_registers[i]], [local_register], parameters[i].typ))
            end
            for i = 0; i < declarations.length(); i++
                local_register = VirtualRegister(declarations[i].typ, declarations[i].id, "stack")
                function_entry_cfg.add_instruction(Instruction("Allocation", [], [local_register], declarations[i].typ))
            end
        else
            # Otherwise, set up bindings in the top block
            for i = 0; i < parameters.length!(); i++
                function_entry_cfg.write_variable(parameters[i].id, param_registers[i])
            end
        end
        last_node = body.translate_stmt(function_entry_cfg, function_exit_cfg)
        function_exit_cfg.seal()
        if last_node.is_conditional?().negate() && last_node.successor == {blz.nil}
            last_node.set_successor(function_exit_cfg)
        end
        function_exit_cfg.add_instruction(Instruction("Return", [return_type.default_value()], [], return_type))
        llvm = llvm + function_entry_cfg.emit_llvm() + "\n}"
        return llvm
    end


end

:return_equivalence? (node)
    if node.type == "ReturnNode"
        return true
    else if node.type == "IfNode"
        return return_equivalence? (node.main) && return_equivalence? (node.els)
    else if node.type == "BlockNode"
        statements = node.subnodes
        for i = 0; i < statements.length! (); i++
            if return_equivalence? (statements [i])
                if i != statements.length! () - 1
                    print("Dead code in block starting on line " + statements[i].line)
                    primitive_type("error")
                end
                return true
            end
        end
    end
    false
end

:parse_function(json)
    line = json["line"]
    id = json["id"]
    return_type = parse_type(json["return_type"])
    body = parse_block_node(json["body"])
    parse_param = (x -> parse_declaration(x, "stack"))
    parameters = json["parameters"].map!(parse_param)
    declarations = json["declarations"].map!(parse_param)
    Function!(line, id, return_type, body, parameters, declarations)
end
