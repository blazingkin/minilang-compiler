require ast/block_node
require declaration
require types/function_type
require types/type_factory
require types/type_error
require types/primitive_type
require tables/symbol_table
require syntax_exception
require cfg/cfg_node
require instructions/instruction
require instructions/arm_instruction
require instructions/register
require interference_graph/interference_node
require minilang_compiler
import Set
import DataStructures
import Lists


constructor Function(line, id, return_type, body, parameters, declarations)

    :show
        "<Function " + id + " " + line + " " + typ + "\n\t" + parameters + " " + declarations  + "\n\t" + body  + ">"
    end

    input_types = parameters.map(x -> x.typ)
    typ = FunctionType(input_types, return_type)

    :typecheck(id_map, struct_map)
        # bind local variables in the id_map
        for i = 0; i < parameters.length!(); i++
            id_map[parameters[i].id] = parameters[i]
        end
        for i = 0; i < declarations.length!(); i++
            id_map[declarations[i].id] = declarations[i]
        end
        symbol_table = SymbolTable(id_map, typ)
        if return_type != primitive_type("void") && return_equivalence? (body).negate()
            print("Function "+id+" is not void and does not return in all cases!")
            primitive_type("error")
        end
        result = body.typecheck(symbol_table, struct_map)
    end

    :copy
        this
    end

    :blocks_in_function(ext)
        result = Set([ext])
        result_length = 0
        while result_length != result.size()
            result_length = result.size()
            entries = result.values()
            for i = 0; i < entries.length!(); i++
                for j = 0; j < entries[i].predecessors.length(); j++
                    result.add(entries[i].predecessors[j])
                end
            end
        end
        return result
    end

    :emit_arm
        function_entry_cfg = CFGNode()
        function_entry_cfg.sealed = true
        function_exit_cfg = CFGNode()
        function_entry_cfg.add_arm_instruction(ARMInstruction("push", [], ["{fp, lr}"]))
        function_entry_cfg.add_arm_instruction(ARMInstruction("add", [ARMRegister(13), 4], [ARMRegister(11)]))
        function_entry_cfg.add_arm_instruction(ARMInstruction("push", [], ["{r4-r10}"]))
        param_registers = []
        # Move variables from registers / stack to 
        # Emit the stack if we are using it
        for i = 0; i < parameters.length!(); i++
            if i < 4
                # Copy parameter from r_i into local register
                local_register = VirtualRegister(parameters[i].typ, parameters[i].id, "stack")
                function_entry_cfg.add_instruction(Instruction("add", [ARMRegister(i), 0], [local_register], parameters[i].typ))
                param_registers[i] = local_register
            else
                # Copy parameter from stack into local register
                param_registers[i] = VirtualRegister(parameters[i].typ, parameters[i].id, "stack")
            end
        end
        for i = 0; i < declarations.length(); i++
            local_register = VirtualRegister(declarations[i].typ, declarations[i].id, "stack")
            function_entry_cfg.add_instruction(Instruction("Allocation", [], [local_register], declarations[i].typ))
        end
        # Set up bindings in the top block
        for i = 0; i < parameters.length!(); i++
            function_entry_cfg.write_variable(parameters[i].id, param_registers[i])
        end

        # Translate the graph into instructions
        last_node = body.translate_stmt(function_entry_cfg, function_exit_cfg)
        function_exit_cfg.seal()
        if last_node.is_conditional?().negate() && last_node.successor == {blz.nil}
            last_node.set_successor(function_exit_cfg)
        end

        # Translate phi instructions into psuedo-phis
        function_blocks = blocks_in_function(function_exit_cfg).values()
        for i = 0; i < function_blocks.length(); i++
            function_blocks[i].resolve_phis_arm()
        end

        # Generate the arm instructions
        for i = 0; i < function_blocks.length(); i++
            function_blocks[i].generate_arm()
        end

        # Generate gen and kill sets for register allocation
        allocate_registers_arm(function_blocks)
        function_exit_cfg.add_arm_instruction_at_beginning(ARMInstruction("pop", [], ["{fp, pc}"]))
        function_exit_cfg.add_arm_instruction_at_beginning(ARMInstruction("sub", [ARMRegister(11), 4], [ARMRegister(13)]))
        function_exit_cfg.add_arm_instruction_at_beginning(ARMInstruction("pop", [], ["{r4-r10}"]))

        return id + ":\n" + function_entry_cfg.emit_arm() + "\n"
    end

    :allocate_registers_arm(function_blocks)
        for i = 0; i < function_blocks.length(); i++
            function_blocks[i].create_gen_kill_sets()
        end
        changed = true
        while changed
            changed = false
            for i = 0; i < function_blocks.length(); i++
                changed = changed || function_blocks[i].generate_live_out_sets()
            end
        end
        graph = generate_interference_graph(function_blocks)
        stack = deconstruct_graph(graph)
        colored_graph = reconstruct_graph(stack)
        colorings = {}
        for i = 0; i < colored_graph.length(); i++
            if colored_graph[i].color == {blz.nil}
                colorings[colored_graph[i].register] = "spill"
            else
                colorings[colored_graph[i].register] = colored_graph[i].color
            end
        end
        replace_with_colorings(function_blocks, colorings)
    end

    :replace_with_colorings(function_blocks, colorings)
        for i = 0; i < function_blocks.length(); i++
            block = function_blocks[i]
            for j = 0; j < block.arm_instruction_list.size(); j++
                instruction = block.arm_instruction_list[j]
                instruction.replace_registers(colorings)
            end
        end
    end

    # Graph -> Stack of registers + edges
    :deconstruct_graph(graph)
        result = Stack()
        while graph.size() > 0
            # Order lists for removal, highest priority to remove is the first
            node = graph.least()
            position = graph.index_of(node)
            result.push(node)
            neighbors = node.edges.values()
            for i = 0; i < neighbors.length(); i++
                neighbors[i].remove_edge_from_this(node)
            end
            graph.remove!(position)
        end
        result
    end

    # Stack of registers + edges -> Colored Graph
    :reconstruct_graph(stack)
        possible_registers = range(9).map(x -> ARMRegister(x))
        spilling = false
        new_graph = []
        while stack.size() > 0
            node = stack.pop()
            new_graph.add!(node)
            if node.register.type == "ARM_Register"
                node.color = node.register
            else
                # Try to color the node
                not_found = true
                for i = possible_registers.length() - 1; i >= 0 && not_found; i--
                    neighbors = node.edges.values()
                    color = possible_registers[i]
                    can_color = true
                    for j = 0; j < neighbors.length(); j++
                        # If any of the neighbors are not compatible, then we can not color
                        if neighbors[j].is_compatible?(color).negate()
                            can_color = false
                        end
                    end
                    if can_color
                        node.color = color
                        not_found = false
                    end
                end
                if node.color == {blz.nil}
                    spilling = true
                    node.spilled = true
                end
            end
        end
        return new_graph
    end

    :resolve_coloring

    end

    :emit_llvm
        llvm = "define " + return_type + " @" + id + "("
        param_registers = []
        for i = 0; i < parameters.length(); i++
            if i != 0
                llvm = llvm + ", "
            end
            param_registers[i] = VirtualRegister(parameters[i].typ, "_P_"+parameters[i].id, "parameters")
            llvm = llvm + parameters[i].typ + " " + param_registers[i].emit_llvm()
        end
        llvm = llvm + ")\n{"
        function_entry_cfg = CFGNode()
        function_entry_cfg.sealed = true
        function_exit_cfg = CFGNode()
        if stack_based?()
            # Emit the stack if we are using it
            for i = 0; i < parameters.length!(); i++
                local_register = VirtualRegister(parameters[i].typ, parameters[i].id, "stack")
                function_entry_cfg.add_instruction(Instruction("Allocation", [], [local_register], parameters[i].typ))
                function_entry_cfg.add_instruction(Instruction("Store", [param_registers[i]], [local_register], parameters[i].typ))
            end
            for i = 0; i < declarations.length(); i++
                local_register = VirtualRegister(declarations[i].typ, declarations[i].id, "stack")
                function_entry_cfg.add_instruction(Instruction("Allocation", [], [local_register], declarations[i].typ))
            end
        else
            # Otherwise, set up bindings in the top block
            for i = 0; i < parameters.length!(); i++
                function_entry_cfg.write_variable(parameters[i].id, param_registers[i])
            end
        end
        last_node = body.translate_stmt(function_entry_cfg, function_exit_cfg)
        function_exit_cfg.seal()
        if last_node.is_conditional?().negate() && last_node.successor == {blz.nil}
            last_node.set_successor(function_exit_cfg)
        end
        function_exit_cfg.add_instruction(Instruction("Return", [return_type.default_value()], [], return_type))
        llvm = llvm + function_entry_cfg.emit_llvm() + "\n}"
        return llvm
    end

    # [CFGNodes] -> [InterferenceNodes]
    :generate_interference_graph(function_blocks)
        interference_graph = {}
        for n = 0; n < function_blocks.length(); n++
            cur_block = function_blocks[n]
            for i = 0; i < cur_block.arm_instruction_list.length(); i++
                cur_instruction = cur_block.arm_instruction_list[i]
                for j = 0; j < cur_instruction.destination_registers.length(); j++
                    if (interference_graph.has_key? (cur_instruction.destination_registers[j])).negate()
                        interference_graph [cur_instruction.destination_registers[j]] = InterferenceNode(cur_instruction.destination_registers[j])
                    end
                end
                for j = 0; j < cur_instruction.source_registers.length(); j++ 
                    if (interference_graph.has_key? (cur_instruction.source_registers[j])).negate()
                        interference_graph [cur_instruction.source_registers[j]] = InterferenceNode(cur_instruction.source_registers[j])
                    end
                end
            end
        end
        for n = 0; n < function_blocks.length(); n++
            cur_block = function_blocks[n]
            cur_live_set = cur_block.live_out
            for i = cur_block.arm_instruction_list.length() - 1; i >= 0 ; i--
                cur_instruction = cur_block.arm_instruction_list[i]
                for j = 0; j < cur_instruction.destination_registers.length(); j++
                    cur_target = cur_instruction.destination_registers[j]
                    cur_live_set.remove(cur_target)
                    cur_live_set_values = cur_live_set.values()
                    for k = 0; k < cur_live_set_values.length(); k++
                        e = cur_live_set_values[k]
                        g = interference_graph[e]
                        interference_graph[cur_target].add_edge(g)
                    end
                end
                for j = 0; j < cur_instruction.source_registers.length(); j++ 
                    cur_live_set.add(cur_instruction.source_registers[j])
                end
            end
        end
        interference_graph.values()
    end

end

:return_equivalence? (node)
    if node.type == "ReturnNode"
        return true
    else if node.type == "IfNode"
        return return_equivalence? (node.main) && return_equivalence? (node.els)
    else if node.type == "BlockNode"
        statements = node.subnodes
        for i = 0; i < statements.length! (); i++
            if return_equivalence? (statements [i])
                if i != statements.length! () - 1
                    print("Dead code in block starting on line " + statements[i].line)
                    primitive_type("error")
                end
                return true
            end
        end
    end
    false
end

:parse_function(json)
    line = json["line"]
    id = json["id"]
    return_type = parse_type(json["return_type"])
    body = parse_block_node(json["body"])
    parse_param = (x -> parse_declaration(x, "stack"))
    parameters = json["parameters"].map!(parse_param)
    declarations = json["declarations"].map!(parse_param)
    Function!(line, id, return_type, body, parameters, declarations)
end
