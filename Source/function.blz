require ast/block_node
require declaration
require types/function_type
require types/type_factory
require types/type_error
require types/primitive_type
require tables/symbol_table
require syntax_exception

constructor Function(line, id, return_type, body, parameters, declarations)

    :show
        "<Function " + id + " " + line + " " + typ + "\n\t" + parameters + " " + declarations  + "\n\t" + body  + ">"
    end

    input_types = parameters.map(x -> x.typ)
    typ = FunctionType(input_types, return_type)

    :typecheck(id_map, struct_map)
        # bind local variables in the id_map
        for i = 0; i < parameters.length!(); i++
            id_map[parameters[i].id] = parameters[i]
        end
        for i = 0; i < declarations.length!(); i++
            id_map[declarations[i].id] = declarations[i]
        end
        symbol_table = SymbolTable(id_map, typ)
        if return_type != primitive_type("void") && return_equivalence? (body).negate()
            print("Function "+id+" is not void and does not return in all cases!")
            primitive_type("error")
        end
        result = body.typecheck(symbol_table, struct_map)
    end

    :emit_llvm
        llvm = "define " + return_type + " @" + id + "("
        for i = 0; i < parameters.length(); i++
            if i != 0
                llvm = llvm + ", "
            end
            llvm = llvm + parameters [i].typ + " %_P_" + parameters [i].id
        end
        llvm = llvm + ")"
        return llvm
    end

    print(emit_llvm())

end

:return_equivalence? (node)
    if node.type == "ReturnNode"
        return true
    else if node.type == "IfNode"
        return return_equivalence? (node.main) && return_equivalence? (node.els)
    else if node.type == "BlockNode"
        statements = node.subnodes
        for i = 0; i < statements.length! (); i++
            if return_equivalence? (statements [i])
                if i != statements.length! () - 1
                    print("Dead code in block starting on line " + statements[i].line)
                    primitive_type("error")
                end
                return true
            end
        end
    end
    false
end

:parse_function(json)
    line = json["line"]
    id = json["id"]
    return_type = parse_type(json["return_type"])
    body = parse_block_node(json["body"])
    parse_param = (x -> parse_declaration(x, "stack"))
    parameters = json["parameters"].map!(parse_param)
    declarations = json["declarations"].map!(parse_param)
    Function!(line, id, return_type, body, parameters, declarations)
end
