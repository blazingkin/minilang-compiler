require ast/block_node
require declaration
require types/function_type
require types/type_factory
require types/type_error
require types/primitive_type
require tables/symbol_table
require syntax_exception
require cfg/cfg_node
require instructions/instruction
require instructions/arm_instruction
require instructions/register
require interference_graph/interference_node
require minilang_compiler
import Set

constructor Function(line, id, return_type, body, parameters, declarations)

    :show
        "<Function " + id + " " + line + " " + typ + "\n\t" + parameters + " " + declarations  + "\n\t" + body  + ">"
    end

    input_types = parameters.map(x -> x.typ)
    typ = FunctionType(input_types, return_type)

    :typecheck(id_map, struct_map)
        # bind local variables in the id_map
        for i = 0; i < parameters.length!(); i++
            id_map[parameters[i].id] = parameters[i]
        end
        for i = 0; i < declarations.length!(); i++
            id_map[declarations[i].id] = declarations[i]
        end
        symbol_table = SymbolTable(id_map, typ)
        if return_type != primitive_type("void") && return_equivalence? (body).negate()
            print("Function "+id+" is not void and does not return in all cases!")
            primitive_type("error")
        end
        result = body.typecheck(symbol_table, struct_map)
    end

    :copy
        this
    end

    :blocks_in_function(ext)
        result = Set([ext])
        result_length = 0
        while result_length != result.size()
            result_length = result.size()
            entries = result.values()
            for i = 0; i < entries.length!(); i++
                for j = 0; j < entries[i].predecessors.length(); j++
                    result.add(entries[i].predecessors[j])
                end
            end
        end
        return result
    end

    :emit_arm
        function_entry_cfg = CFGNode()
        function_entry_cfg.sealed = true
        function_exit_cfg = CFGNode()
        function_entry_cfg.add_instruction(ARMInstruction("push", [], ["{fp, lr}"]))
        param_registers = []
        # Move variables from registers / stack to 
        # Emit the stack if we are using it
        for i = 0; i < parameters.length!(); i++
            if i < 4
                # Copy parameter from r_i into local register
                local_register = VirtualRegister(parameters[i].typ, parameters[i].id, "stack")
                function_entry_cfg.add_instruction(Instruction("add", [ARMRegister(i), 0], [local_register], parameters[i].typ))
                param_registers[i] = local_register
            else
                # Copy parameter from stack into local register
                param_registers[i] = VirtualRegister(parameters[i].typ, parameters[i].id, "stack")
            end
        end
        for i = 0; i < declarations.length(); i++
            local_register = VirtualRegister(declarations[i].typ, declarations[i].id, "stack")
            function_entry_cfg.add_instruction(Instruction("Allocation", [], [local_register], declarations[i].typ))
        end
        # Set up bindings in the top block
        for i = 0; i < parameters.length!(); i++
            function_entry_cfg.write_variable(parameters[i].id, param_registers[i])
        end

        # Translate the graph into instructions
        last_node = body.translate_stmt(function_entry_cfg, function_exit_cfg)
        function_exit_cfg.seal()
        if last_node.is_conditional?().negate() && last_node.successor == {blz.nil}
            last_node.set_successor(function_exit_cfg)
        end

        # Translate phi instructions into psuedo-phis
        function_blocks = blocks_in_function(function_exit_cfg).values()
        for i = 0; i < function_blocks.length(); i++
            function_blocks[i].resolve_phis_arm()
        end

        # Generate the arm instructions
        for i = 0; i < function_blocks.length(); i++
            function_blocks[i].generate_arm()
        end
        function_exit_cfg.add_instruction(ARMInstruction("pop", [], ["{fp, pc}"]))

        # Generate gen and kill sets for register allocation
        allocate_registers_arm(function_blocks)

        return id + ":\n" + function_entry_cfg.emit_arm() + "\n"
    end

    :allocate_registers_arm(function_blocks)
        for i = 0; i < function_blocks.length(); i++
            function_blocks[i].create_gen_kill_sets()
        end
        changed = true
        while changed
            changed = false
            for i = 0; i < function_blocks.length(); i++
                changed = changed || function_blocks[i].generate_live_out_sets()
            end
        end
        generate_interference_graph(function_blocks)
    end

    :emit_llvm
        llvm = "define " + return_type + " @" + id + "("
        param_registers = []
        for i = 0; i < parameters.length(); i++
            if i != 0
                llvm = llvm + ", "
            end
            param_registers[i] = VirtualRegister(parameters[i].typ, "_P_"+parameters[i].id, "parameters")
            llvm = llvm + parameters[i].typ + " " + param_registers[i].emit_llvm()
        end
        llvm = llvm + ")\n{"
        function_entry_cfg = CFGNode()
        function_entry_cfg.sealed = true
        function_exit_cfg = CFGNode()
        if stack_based?()
            # Emit the stack if we are using it
            for i = 0; i < parameters.length!(); i++
                local_register = VirtualRegister(parameters[i].typ, parameters[i].id, "stack")
                function_entry_cfg.add_instruction(Instruction("Allocation", [], [local_register], parameters[i].typ))
                function_entry_cfg.add_instruction(Instruction("Store", [param_registers[i]], [local_register], parameters[i].typ))
            end
            for i = 0; i < declarations.length(); i++
                local_register = VirtualRegister(declarations[i].typ, declarations[i].id, "stack")
                function_entry_cfg.add_instruction(Instruction("Allocation", [], [local_register], declarations[i].typ))
            end
        else
            # Otherwise, set up bindings in the top block
            for i = 0; i < parameters.length!(); i++
                function_entry_cfg.write_variable(parameters[i].id, param_registers[i])
            end
        end
        last_node = body.translate_stmt(function_entry_cfg, function_exit_cfg)
        function_exit_cfg.seal()
        if last_node.is_conditional?().negate() && last_node.successor == {blz.nil}
            last_node.set_successor(function_exit_cfg)
        end
        function_exit_cfg.add_instruction(Instruction("Return", [return_type.default_value()], [], return_type))
        llvm = llvm + function_entry_cfg.emit_llvm() + "\n}"
        return llvm
    end

    :generate_interference_graph(function_blocks)
        interference_graph = {}
        for n = 0; n < function_blocks.length(); n++
            cur_block = function_blocks[n]
            for i = 0; i < cur_block.arm_instruction_list.length(); i++
                cur_instruction = cur_block.arm_instruction_list[i]
                for j = 0; j < cur_instruction.destinations.length(); j++
                    if (interference_graph.has_key? (cur_instruction.destinations[j])).negate()
                        interference_graph [cur_instruction.destinations[j]] = InterferenceNode(cur_instruction.destinations[j])
                    end
                end
                for j = 0; j < cur_instruction.sources.length(); j++ 
                    if (interference_graph.has_key? (cur_instruction.sources[j])).negate()
                        interference_graph [cur_instruction.sources[j]] = InterferenceNode(cur_instruction.sources[j])
                    end
                end
            end
        end

        for n = 0; n < function_blocks.length(); n++
            cur_bock = function_blocks[n]
            cur_live_set = cur_block.live_out
            for i = cur_block.arm_instruction_list.length() - 1; i >= 0 ; i--
                cur_instruction = cur_block.arm_instruction_list[i]
                for j = 0; j < cur_instruction.destinations.length(); j++
                    cur_target = cur_instruction.destinations[j]
                    cur_live_set.remove(cur_target)
                    cur_live_set_values = cur_live_set.values()
                    for k = 0; k < cur_live_set_values.length(); k++
                        interference_graph[cur_target].add_edge(interference_graph[cur_live_set_values[k]])
                    end
                end
                for j = 0; j < cur_instruction.sources.length(); j++ 
                    cur_live_set.add(cur_instruction.sources[j])
                end
            end
        end
        interference_graph
    end

end

:return_equivalence? (node)
    if node.type == "ReturnNode"
        return true
    else if node.type == "IfNode"
        return return_equivalence? (node.main) && return_equivalence? (node.els)
    else if node.type == "BlockNode"
        statements = node.subnodes
        for i = 0; i < statements.length! (); i++
            if return_equivalence? (statements [i])
                if i != statements.length! () - 1
                    print("Dead code in block starting on line " + statements[i].line)
                    primitive_type("error")
                end
                return true
            end
        end
    end
    false
end

:parse_function(json)
    line = json["line"]
    id = json["id"]
    return_type = parse_type(json["return_type"])
    body = parse_block_node(json["body"])
    parse_param = (x -> parse_declaration(x, "stack"))
    parameters = json["parameters"].map!(parse_param)
    declarations = json["declarations"].map!(parse_param)
    Function!(line, id, return_type, body, parameters, declarations)
end
