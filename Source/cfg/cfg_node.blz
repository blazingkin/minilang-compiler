require ../instructions/register
require ../instructions/instruction
node_counter = 1

printed_counters = []
printed_llvm_counters = []

constructor CFGNode()

    predecessors = []
    label = (node_counter++)
    text_label = "L" + label
    true_successor = {blz.nil}
    false_successor = {blz.nil}
    conditional_register = VirtualRegister("i1")
    printed = false

    # Milestone 3
    sealed = false
    variable_map = {}
    phis = []
    incomplete_phis = []

    successor = {blz.nil}
    instructions = []

    :seal
        this.sealed = true
        # Do stuff
    end

    :show
        "Node " + text_label
    end

    :copy
        this
    end

    :is_conditional?
        true_successor != {blz.nil} || false_successor != {blz.nil}
    end

    :add_predecessor(node)
        # Only add it if it does not already exist
        if predecessors.contains?(node).negate()
            predecessors.add!(node)
        else
            predecessors
        end
    end

    :set_true_successor(node)
        node.add_predecessor(this)
        true_successor = node
    end

    :set_false_successor(node)
        node.add_predecessor(this)
        false_successor = node
    end

    :set_successor(node)
        node.add_predecessor(this)
        successor = node
    end

    :add_instruction(instruction)
        instructions.add!(instruction)
    end

    :emit_instructions
        if printed_counters.contains?(label)
            arr = []
            return arr
        end
        emit_instr = [Instruction("Label", label)]
        printed_counters.add!(label)
        emit_instr.concatenate!(instructions)
        if is_conditional?()
            emit_instr.add!(Instruction("Branch", [conditional_register], [true_successor.label, false_successor.label]))
        else if successor != {blz.nil}
            emit_instr.add!(Instruction("Branch", [], [successor.label]))
        end
        emit_instr
    end

    emitted_llvm = false
    :emit_llvm
        append_newlines = (x,y -> x + "\n" + y)
        if printed_llvm_counters.contains?(label)
            return ""
        end
        printed_llvm_counters.add!(label)
        instr = emit_instructions().map!(x -> x.emit_llvm()).fold_left("", append_newlines)
        if is_conditional?()
            instr = instr + "\n" + true_successor.emit_llvm()
            instr = instr + "\n" + false_successor.emit_llvm()
        else if successor != {blz.nil} && successor != this
            instr = instr + "\n" + successor.emit_llvm()
        end
        instr
    end

end