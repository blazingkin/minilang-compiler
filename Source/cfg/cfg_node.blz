require ../instructions/register
require ../instructions/instruction
require ../instructions/arm_instruction
require ../minilang_compiler
node_counter = 1

printed_counters = []
printed_llvm_counters = []
printed_arm_counters = []

constructor CFGNode()

    predecessors = []
    label = (node_counter++)
    text_label = "LU" + label
    true_successor = {blz.nil}
    false_successor = {blz.nil}
    conditional_register = VirtualRegister("i1")
    printed = false

    # Milestone 3
    sealed = false
    variable_map = {}
    phis = []
    incomplete_phis = []

    successor = {blz.nil}
    instructions = []

    :seal
        sealed = true
        for i = 0; i < incomplete_phis.length!(); i++
            phi_id = incomplete_phis[i].sources[0]
            phi_typ = incomplete_phis[i].typ
            phi_src = []
            for j = 0; j < predecessors.length!(); j++
                phi_src.add!(predecessors[j].find_variable(phi_id, phi_typ))
                phi_src.add!(predecessors[j])
            end
            incomplete_phis[i].sources = phi_src
            phis.add!(incomplete_phis[i])
        end
        incomplete_phis = []
    end

    printing_predecessors = false
    :print_predecessors(depth)
        if depth == {blz.nil}
            depth = 0
        end
        if printing_predecessors
            return ""
        end
        padding_char = ""
        for i = 0; i < depth; i++
            padding_char = padding_char + "\t"
        end
        printing_predecessors = true
        print(padding_char + this.show())
        for i = 0; i < predecessors.length!(); i++
            predecessors[i].print_predecessors(depth + 1)
        end
        printing_predecessors = false
    end

    :write_variable(id, val)
        variable_map[id] = val
    end

    :find_variable(id, typ)
        if variable_map.has_key?(id)
            variable_map[id]
        else
            find_variable_from_predecessors(id, typ)
        end
    end

    :find_variable_from_predecessors(id, typ)
        if sealed.negate()
            phi_dest = VirtualRegister(typ)
            instr = Instruction("Phi", [id], [phi_dest], typ)
            incomplete_phis.add!(instr)
            val = phi_dest
        else if predecessors.length!() == 0
            throw "Uninitialized variable " + id
        else if predecessors.length!() == 1
            val = predecessors[0].find_variable(id, typ)
        else
            phi_dest = VirtualRegister(typ)
            phi_src = []
            write_variable(id, phi_dest)
            for i = 0; i < predecessors.length!(); i++
                phi_src.add!(predecessors[i].find_variable(id, typ))
                phi_src.add!(predecessors[i])
            end
            instr = Instruction("Phi", phi_src, [phi_dest], typ)
            phis.add!(instr)
            val = phi_dest
        end
        write_variable(id, val)
        return val
    end

    :show
        "Node " + text_label
    end

    :copy
        this
    end

    :is_conditional?
        true_successor != {blz.nil} || false_successor != {blz.nil}
    end

    :add_predecessor(node)
        # Only add it if it does not already exist
        if predecessors.contains?(node).negate()
            predecessors.add!(node)
        else
            predecessors
        end
    end

    :remove_predecessor(node)
        predecessors = predecessors.filter!(x -> x != node)
    end

    :set_true_successor(node)
        if true_successor != {blz.nil}
            true_successor.remove_predecessor(this)
        end
        node.add_predecessor(this)
        true_successor = node
    end

    :set_false_successor(node)
        if false_successor != {blz.nil}
            false_successor.remove_predecessor(this)
        end
        node.add_predecessor(this)
        false_successor = node
    end

    :set_successor(node)
        if successor != {blz.nil}
            successor.remove_predecessor(this)
        end
        node.add_predecessor(this)
        successor = node
    end

    :add_instruction(instruction)
        instructions.add!(instruction)
    end

    :add_instruction_at_beginning(instruction)
        instructions = [instruction].append(this.instructions)
    end

    :emit_instructions
        if printed_counters.contains?(label)
            arr = []
            return arr
        end
        emit_instr = []
        printed_counters.add!(label)
        emit_instr.concatenate!(instructions)
        if is_conditional?()
            emit_instr.add!(Instruction("Branch", [conditional_register], [true_successor.label, false_successor.label]))
        else if successor != {blz.nil}
            emit_instr.add!(Instruction("Branch", [], [successor.label]))
        end
        emit_instr
    end

    :append_newlines(a, b)
        return a + "\n" + b
    end

    :emit_llvm
        if printed_llvm_counters.contains?(label)
            return ""
        end
        printed_llvm_counters.add!(label)
        instr = "\n" + text_label + ":"
        instr = instr + (phis.map!(x -> x.emit_llvm())).fold_left("", append_newlines)
        instr = instr + "\n" + (emit_instructions().map!(x -> x.emit_llvm()).fold_left("", append_newlines))
        if is_conditional?()
            instr = instr + "\n" + true_successor.emit_llvm()
            instr = instr + "\n" + false_successor.emit_llvm()
        else if successor != {blz.nil} && successor != this
            instr = instr + "\n" + successor.emit_llvm()
        end
        instr
    end

    :resolve_phis_arm
        for i = 0; i < phis.length!(); i++
            temporary_for_phi = VirtualRegister()
            for j = 0; j < phis[i].sources.length(); j = j + 2
                val = phis[i].sources[j]
                pred_block = phis[i].sources[j + 1]
                pred_block.add_instruction(ARMInstruction("mov", [val], [temporary_for_phi]))
            end
            this.add_instruction_at_beginning(ARMInstruction("mov", [temporary_for_phi], [phis[i].destinations[0]]))

        end
    end

    :emit_arm
        if printed_arm_counters.contains?(label)
            return ""
        end
        printed_arm_counters.add!(label)
        instr = text_label + ":"
        instructions = emit_instructions()
        arm_instructions = []
        for i = 0; i < instructions.length!(); i++
            arm_instructions.append!(instructions[i].translate_to_arm())
        end
        for i = 0; i < arm_instructions.length!(); i++
            instr = instr + "\n" + arm_instructions[i].emit_arm()
        end
        if is_conditional?()
            instr = instr + "\n" + true_successor.emit_arm()
            instr = instr + "\n" + false_successor.emit_arm()
        else if successor != {blz.nil} && successor != this
            instr = instr + "\n" + successor.emit_arm()
        end
        instr
    end

end