require ../instructions/register
require ../instructions/instruction
require ../minilang_compiler
node_counter = 1

printed_counters = []
printed_llvm_counters = []

constructor CFGNode()

    predecessors = []
    label = (node_counter++)
    text_label = "L" + label
    true_successor = {blz.nil}
    false_successor = {blz.nil}
    conditional_register = VirtualRegister("i1")
    printed = false

    # Milestone 3
    sealed = false
    variable_map = {}
    phis = []
    incomplete_phis = []

    successor = {blz.nil}
    instructions = []

    :seal
        this.sealed = true
        for i = 0; i < incomplete_phis.length!(); i++
            phi_id = incomplete_phis[i].sources[0]
            phi_typ = incomplete_phis[i].typ
            phi_src = []
            for j = 0; j < predecessors.length!(); j++
                phi_src.add!(predecessors[j].find_variable(phi_id, phi_typ))
                phi_src.add!("%" + predecessors[j].text_label)
            end
            incomplete_phis[i].sources = phi_src
            phis.add!(incomplete_phis[i])
        end
        incomplete_phis = []
    end

    :write_variable(id, val)
        variable_map[id] = val
    end

    :find_variable(id, typ)
        if variable_map.has_key?(id)
            variable_map[id]
        else
            find_variable_from_predecessors(id, typ)
        end
    end

    :find_variable_from_predecessors(id, typ)
        if sealed.negate()
            phi_dest = VirtualRegister(typ)
            instr = Instruction("Phi", [id], [phi_dest], typ)
            incomplete_phis.add!(instr)
            val = phi_dest
        else if predecessors.length!() == 0
            throw "Uninitialized variable " + id
        else if predecessors.length!() == 1
            val = predecessors[0].find_variable(id, typ)
        else
            phi_dest = VirtualRegister(typ)
            phi_src = []
            for i = 0; i < predecessors.length!(); i++
                phi_src.add!(predecessors[i].find_variable(id, typ))
                phi_src.add!("%" + predecessors[i].text_label)
            end
            instr = Instruction("Phi", phi_src, [phi_dest], typ)
            phis.add!(instr)
            val = phi_dest
        end
        write_variable(id, val)
    end

    :show
        "Node " + text_label
    end

    :copy
        this
    end

    :is_conditional?
        true_successor != {blz.nil} || false_successor != {blz.nil}
    end

    :add_predecessor(node)
        # Only add it if it does not already exist
        if predecessors.contains?(node).negate()
            predecessors.add!(node)
        else
            predecessors
        end
    end

    :set_true_successor(node)
        node.add_predecessor(this)
        true_successor = node
    end

    :set_false_successor(node)
        node.add_predecessor(this)
        false_successor = node
    end

    :set_successor(node)
        node.add_predecessor(this)
        successor = node
    end

    :add_instruction(instruction)
        instructions.add!(instruction)
    end

    :emit_instructions
        if printed_counters.contains?(label)
            arr = []
            return arr
        end
        emit_instr = [Instruction("Label", label)]
        printed_counters.add!(label)
        emit_instr.concatenate!(instructions)
        if is_conditional?()
            emit_instr.add!(Instruction("Branch", [conditional_register], [true_successor.label, false_successor.label]))
        else if successor != {blz.nil}
            emit_instr.add!(Instruction("Branch", [], [successor.label]))
        end
        emit_instr
    end

    emitted_llvm = false
    :emit_llvm
        append_newlines = (x,y -> x + "\n" + y)
        if printed_llvm_counters.contains?(label)
            return ""
        end
        printed_llvm_counters.add!(label)
        instr = (phis.map!(x -> x.emit_llvm())).fold_left("", append_newlines)
        instr = instr + "\n" + (emit_instructions().map!(x -> x.emit_llvm()).fold_left("", append_newlines))
        if is_conditional?()
            instr = instr + "\n" + true_successor.emit_llvm()
            instr = instr + "\n" + false_successor.emit_llvm()
        else if successor != {blz.nil} && successor != this
            instr = instr + "\n" + successor.emit_llvm()
        end
        instr
    end

end