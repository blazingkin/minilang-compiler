require register
require arm_instruction
constructor InstructionError(message)
    :show
        message
    end
end

MAX_THAT_CAN_FIT_IN_OP_TWO = (2 ** 9) - 1
constructor Instruction(instruction_type, sources, destinations, typ)

    if sources.type == "Array"
        for i = 0; i < sources.length!(); i++
            if sources[i].type == "VirtualRegister"
                sources[i].add_use(this)
            end
        end
    end
    
    if destinations.type == "Array"
        for i = 0; i < destinations.length!(); i++
            if destinations[i].type == "VirtualRegister"
                destinations[i].add_source(this)
            end
        end
    else if destinations.type == "VirtualRegister"
        destinations.add_source(this)
    end

    :show
        "<" + instruction_type + " from " + sources + " to " + destinations + ">"
    end

    :copy
        this
    end

    :val_to_llvm(val)
        if val.type == "Integer" || val.type == "String"
            val
        else if val.type == "CFGNode"
            val.text_label
        else
            val.emit_llvm()
        end
    end

    :val_to_arm(val)
        if val.type == "Integer" || val.type == "String"
            val
        else
            val.emit_arm()
        end
    end

    :emit_llvm
        # "Label", label_name
        if instruction_type == "Label"
            return "LU" + sources + ":"
        else if instruction_type == "Branch"
            if sources == []
                # Unconditional branch
                return "br label %LU" + destinations[0]
            else
                # Conditional branch
                return "br i1 " + val_to_llvm(sources[0]) + ", label %LU" + destinations[0] + ", label %LU" + destinations[1]
            end
        else if instruction_type == "add" || instruction_type == "mul" || instruction_type == "sdiv" || instruction_type == "sub" || instruction_type == "and" || instruction_type == "or" || instruction_type == "xor"
            # Arithmatic and Boolean instructions
            return val_to_llvm(destinations [0]) + " = " + instruction_type + " " + typ + " " + val_to_llvm(sources [0]) + ", " + val_to_llvm(sources [1])
        else if instruction_type == "Return"
            if sources == []
                return "ret void"
            else
                return "ret " + typ + " " + val_to_llvm(sources [0])
            end
        else if instruction_type == "Comparison"
            return val_to_llvm(destinations [0]) + " = " + "icmp " + sources [0] + " " + typ + " " + val_to_llvm(sources [1]) + ", " + val_to_llvm(sources [2])
        else if instruction_type == "Allocation"
            return val_to_llvm(destinations [0]) + " = alloca " + typ
        else if instruction_type == "bitcast" || instruction_type == "trunc" || instruction_type == "zext"
            return val_to_llvm(destinations [0]) + " = " + instruction_type + " " + typ + " " + val_to_llvm(sources [0]) + " to " + sources [1]
        else if instruction_type == "Load"
            return val_to_llvm(destinations [0]) + " = load " + typ + ", " + typ + "* " + val_to_llvm(sources [0])
        else if instruction_type == "Store"
            return "store " + typ + " " + val_to_llvm(sources [0]) + ", " + typ + "* " + val_to_llvm(destinations [0])
        else if instruction_type == "GetElement"
            return val_to_llvm(destinations [0]) + " = getelementptr " + typ.llvm_no_pointer() + ", " + typ + " " + val_to_llvm(sources [0]) + ", i1 0, i32 " + val_to_llvm(sources [1])
        # Needs to be resoved
        else if instruction_type == "NegateInteger"
            val_to_llvm(destinations[0]) + " = sub i32 0, " + val_to_llvm(sources[0])
        else if instruction_type == "NegateBoolean"
            # Negate by XORing with 1
            val_to_llvm(destinations[0]) + " = xor i32 1, " + val_to_llvm(sources[0])
        else if instruction_type == "FunctionCall"
            if destinations != []
                llvm = val_to_llvm(destinations[0]) + " = "
            else
                llvm = ""
            end
            llvm = llvm + "call " + typ + " @" + sources[0] + "("
            for i = 1; i < sources.length(); i = i + 2
                if i != 1
                    llvm = llvm + ", "
                end
                llvm = llvm + val_to_llvm(sources [i]) + " " + val_to_llvm(sources [i + 1])
            end
            llvm = llvm + ")"
            return llvm
        else if instruction_type == "Phi"
            llvm = val_to_llvm(destinations[0]) + " = phi " + typ
            for i = 0; i < sources.length(); i = i + 2
                if i != 0
                    llvm = llvm + ","
                end
                llvm = llvm + " [ " + val_to_llvm(sources[i]) + ", %" + val_to_llvm(sources[i+1]) + " ]"
            end
            return llvm
        else
            throw InstructionError("Unknown instruction type " + instruction_type)
        end
    end
    
    # Returns an array of ARMInstructions
    :translate_to_arm
        # "Label", label_name
        if instruction_type == "Label"
            result = []
            return result
        else if instruction_type == "mov"
            result = [ARMInstruction("mov", sources, destinations)]
            return result
        else if instruction_type == "Branch"
            if sources == []
                # Unconditional branch
                return [ARMInstruction("b", sources, destinations)]
            else
                # Conditional branch
                # Compare then branch if equal or branch if not equal
                result = []
                result.add!(ARMInstruction("cmp", [sources[0], 1], []))
                result.add!(ARMInstruction("beq", [], [destinations[0]]))
                result.add!(ARMInstruction("bne", [], [destinations[1]]))
                return result
            end
        else if (instruction_type == "add" || instruction_type == "mul" || instruction_type == "sub" || instruction_type == "and")
            return do_arithmatic_and_boolean(instruction_type)
        else if instruction_type == "or"
            return do_arithmatic_and_boolean("orr")
        else if instruction_type == "xor"
            return do_arithmatic_and_boolean("eor")
        else if instruction_type == "sdiv"
            #TODO
            result = []
            result.add!(ARMInstruction("mov", [sources[0]], [ARMRegister(0)]))
            result.add!(ARMInstruction("mov", [sources[1]], [ARMRegister(1)]))
            result.add!(ARMInstruction("bl", [ARMRegister(0), ARMRegister(1), ARMRegister(2), ARMRegister(3)], ["__aeabi_idiv", ARMRegister(0), ARMRegister(1)]))
            result.add!(ARMInstruction("mov", [ARMRegister(1)], [destinations[0]]))
            return result
        else if instruction_type == "Return"
            result = []
            if sources == []
                return result
            else
                result.add!(ARMInstruction("mov", [sources[0]], [ARMRegister(0)]))
                return result
            end
        else if instruction_type == "Comparison"
            #TODO
            result = []
            result.add!(ARMInstruction("mov", ["\#0"], [destinations[0]]))
            result.add!(ARMInstruction("cmp", [sources[1], sources[2]], []))
            move = ""
            if sources[0] == "eq"
              move = "moveq"
            else if sources[0] == "ne"
              move = "movne"
            else if sources[0] == "sgt"
              move = "movgt"
            else if sources[0] == "sge"
              move = "movge"
            else if sources[0] == "slt"
              move = "movlt"
            else if sources[0] == "sle"
              move = "movle"
            end
            result.add!(ARMInstruction(move, ["\#1"], [destinations[0]]))
            return result
        else if instruction_type == "Allocation"
            #TODO
            result = []
            return result
            return val_to_llvm(destinations [0]) + " = alloca " + typ
        else if instruction_type == "bitcast" || instruction_type == "trunc" || instruction_type == "zext"
            return [ARMInstruction("mov", [sources[0]], [destinations[0]])]
        else if instruction_type == "Load"
            #TODO
            result = []
            result.add!(ARMInstruction("ldptr", [sources[0]], [destinations[0]]))
            return result
        else if instruction_type == "Store"
            #TODO
            result = []
            result.add!(ARMInstruction("stptr", [sources[0], destinations[0]], []))
            return result
        else if instruction_type == "GetElement"
            #TODO
            result = []
            result.add!(ARMInstruction("add", [sources[0], "\#" + sources[1] * 4], [destinations[0]]))
            return result
        # Needs to be resoved
        else if instruction_type == "NegateInteger"
            result = []
            if sources[0].type == "Integer" && sources[0] > MAX_THAT_CAN_FIT_IN_OP_TWO
                # Constant that is too big
                scratch_one = VirtualRegister()
                scratch_two = VirtualRegister()
                # Move the lower half into the scratch
                result.add!(ARMInstruction("movw", ["\#:lower16: " + val_to_arm(sources[0])], [scratch_one]))
                # Move the upper half into the scratch
                result.add!(ARMInstruction("movt", ["\#:upper16: " + val_to_arm(sources[0])], [scratch_one]))
                # Load zero into the second scratch
                result.add!(ARMInstruction("mov", ["\#0"], [scratch_two]))
                result.add!(ARMInstruction("sub", [scratch_two, scratch_one], [destinations[0]]))
                return result
            else
                scratch_one = VirtualRegister()
                result.add!(ARMInstruction("mov", ["\#0"], scratch_one))
                result.add!(ARMInstruction("sub", [scratch_one, sources[0]], [destinations[0]]))
                return ld_zero + sub
            end
            return result
        else if instruction_type == "NegateBoolean"
            result = []
            result.add!(ARMInstruction("eor", [sources[0], "\#1"], [destinations[0]]))
            return result
        else if instruction_type == "FunctionCall"
            args = sources.slice(1, sources.length())
            instr = ""
            #TODO
            result = []
            return result
            
            instr = instr + "call " + typ + " @" + sources[0] + "("
            for i = 1; i < sources.length(); i = i + 2
                if i != 1
                    instr = instr + ", "
                end
                instr = instr + val_to_arm(sources [i]) + " " + val_to_arm(sources [i + 1])
            end
            instr = instr + ")"
            if destinations != []
                # If a result is expected, move the result from r0 into the destination register
                instr = instr + "\n" + "mov " + val_to_arm(destinations[0]) + ", r0 ; Store the result"
            end
            return instr
        else if instruction_type == "Phi"
            throw "Phi instructions should not be emitted for ARM"
        else
            throw InstructionError("Unknown instruction type " + instruction_type)
        end
    end

    :do_arithmatic_and_boolean (instruction_code)
        result = []
        if sources[0].type == "Integer"
            # Constant that is too big
            scratch_one = VirtualRegister()
            # Load the lower part of the constant
            result.add!(ARMInstruction("movw", ["\#:lower16: " + val_to_arm(sources[0])], [scratch_one]))
            # Load the upper part of the constant
            result.add!(ARMInstruction("movt", ["\#:upper16: " + val_to_arm(sources[0])], [scratch_one]))
            # Do the operation
            result.add!(ARMInstruction(instruction_code, [scratch_one, sources[1]], [destinations[0]]))
            return result
        else if sources [1].type == "Integer" && ((sources[1] > MAX_THAT_CAN_FIT_IN_OP_TWO) || instruction_type == "mul")
            # Constant that is too big
            scratch_one = VirtualRegister()
            # Load the lower part of the constant
            result.add!(ARMInstruction("movw", ["\#:lower16: " + val_to_arm(sources[1])], [scratch_one]))
            # Load the upper part of the constant
            result.add!(ARMInstruction("movt", ["\#:upper16: " + val_to_arm(sources[1])], [scratch_one]))
            # Do the operation
            result.add!(ARMInstruction(instruction_code, [scratch_one, sources[0]], [destinations[0]]))
            return result
        end
        result.add!(ARMInstruction(instruction_code, [sources[0], sources[1]], [destinations[0]]))
        return result
    end

 :generate_compare_instruction(type)
        result = []
        return result
        default_value = "\#0"
        if type == "<=" || type == ">="
            default_value = "\#1"
        end
        result = "mov " + val_to_arm(destinations[0]) + ", " + default_value + "\n"
        result = result + "cmp " + val_to_arm(sources[0]) + ", " + val_to_arm(sources[1]) + " ; Compare\n"
        if type == "<="
            # Check the opposite and set the result to 0 if it is true
            result = result + "mov "
        else if type == ">="

        else if type == "<"

        else if type == "=="

        else if type == "!="

        else if type == ">"

        end
    end


end
