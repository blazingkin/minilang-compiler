require register
constructor InstructionError(message)
    :show
        message
    end
end

MAX_THAT_CAN_FIT_IN_OP_TWO = (2 ** 9) - 1
constructor Instruction(instruction_type, sources, destinations, typ)

    scratch_registers = determine_scratch_registers()
    fixed_registers = determine_fixed_registers()
    :determine_scratch_registers
        if instruction_type == "NegateInteger"
            if sources[0].type == "Integer" && sources[0] > MAX_THAT_CAN_FIT_IN_OP_TWO
                return [VirtualRegister("i32"), VirtualRegister("i32")]
            else
                return [VirtualRegister("i32")]
            end
        else if instruction_type == "add" || instruction_type == "sub" || instruction_type == "mul"
            if sources[0].type == "Integer" #&& sources[0] > MAX_THAT_CAN_FIT_IN_OP_TWO
                return [VirtualRegister("i32")]
            else if sources[1].type == "Integer" && (sources[1] > MAX_THAT_CAN_FIT_IN_OP_TWO || instruction_type == "mul")
                return [VirtualRegister("i32")]
            end
        end
        []
    end

    :determine_fixed_registers
        if instruction_type == ""
        end
        []
    end

    if sources.type == "Array"
        for i = 0; i < sources.length!(); i++
            if sources[i].type == "VirtualRegister"
                sources[i].add_use(this)
            end
        end
    end
    
    if destinations.type == "Array"
        for i = 0; i < destinations.length!(); i++
            if destinations[i].type == "VirtualRegister"
                destinations[i].add_source(this)
            end
        end
    else if destinations.type == "VirtualRegister"
        destinations.add_source(this)
    end

    :show
        "<" + instruction_type + " from " + sources + " to " + destinations + ">"
    end

    :copy
        this
    end

    :val_to_llvm(val)
        if val.type == "Integer" || val.type == "String"
            val
        else if val.type == "CFGNode"
            val.text_label
        else
            val.emit_llvm()
        end
    end

    :val_to_arm(val)
        if val.type == "Integer" || val.type == "String"
            val
        else
            val.emit_arm()
        end
    end

    :emit_llvm
        # "Label", label_name
        if instruction_type == "Label"
            return "LU" + sources + ":"
        else if instruction_type == "Branch"
            if sources == []
                # Unconditional branch
                return "br label %LU" + destinations[0]
            else
                # Conditional branch
                return "br i1 " + val_to_llvm(sources[0]) + ", label %LU" + destinations[0] + ", label %LU" + destinations[1]
            end
        else if instruction_type == "add" || instruction_type == "mul" || instruction_type == "sdiv" || instruction_type == "sub" || instruction_type == "and" || instruction_type == "or" || instruction_type == "xor"
            # Arithmatic and Boolean instructions
            return val_to_llvm(destinations [0]) + " = " + instruction_type + " " + typ + " " + val_to_llvm(sources [0]) + ", " + val_to_llvm(sources [1])
        else if instruction_type == "Return"
            if sources == []
                return "ret void"
            else
                return "ret " + typ + " " + val_to_llvm(sources [0])
            end
        else if instruction_type == "Comparison"
            return val_to_llvm(destinations [0]) + " = " + "icmp " + sources [0] + " " + typ + " " + val_to_llvm(sources [1]) + ", " + val_to_llvm(sources [2])
        else if instruction_type == "Allocation"
            return val_to_llvm(destinations [0]) + " = alloca " + typ
        else if instruction_type == "bitcast" || instruction_type == "trunc" || instruction_type == "zext"
            return val_to_llvm(destinations [0]) + " = " + instruction_type + " " + typ + " " + val_to_llvm(sources [0]) + " to " + sources [1]
        else if instruction_type == "Load"
            return val_to_llvm(destinations [0]) + " = load " + typ + ", " + typ + "* " + val_to_llvm(sources [0])
        else if instruction_type == "Store"
            return "store " + typ + " " + val_to_llvm(sources [0]) + ", " + typ + "* " + val_to_llvm(destinations [0])
        else if instruction_type == "GetElement"
            return val_to_llvm(destinations [0]) + " = getelementptr " + typ.llvm_no_pointer() + ", " + typ + " " + val_to_llvm(sources [0]) + ", i1 0, i32 " + val_to_llvm(sources [1])
        # Needs to be resoved
        else if instruction_type == "NegateInteger"
            val_to_llvm(destinations[0]) + " = sub i32 0, " + val_to_llvm(sources[0])
        else if instruction_type == "NegateBoolean"
            # Negate by XORing with 1
            val_to_llvm(destinations[0]) + " = xor i32 1, " + val_to_llvm(sources[0])
        else if instruction_type == "FunctionCall"
            if destinations != []
                llvm = val_to_llvm(destinations[0]) + " = "
            else
                llvm = ""
            end
            llvm = llvm + "call " + typ + " @" + sources[0] + "("
            for i = 1; i < sources.length(); i = i + 2
                if i != 1
                    llvm = llvm + ", "
                end
                llvm = llvm + val_to_llvm(sources [i]) + " " + val_to_llvm(sources [i + 1])
            end
            llvm = llvm + ")"
            return llvm
        else if instruction_type == "Phi"
            llvm = val_to_llvm(destinations[0]) + " = phi " + typ
            for i = 0; i < sources.length(); i = i + 2
                if i != 0
                    llvm = llvm + ","
                end
                llvm = llvm + " [ " + val_to_llvm(sources[i]) + ", %" + val_to_llvm(sources[i+1]) + " ]"
            end
            return llvm
        else
            throw InstructionError("Unknown instruction type " + instruction_type)
        end
    end
    
    :emit_arm
        # "Label", label_name
        if instruction_type == "Label"
            return "LU" + sources + ":"
        else if instruction_type == "Branch"
            if sources == []
                # Unconditional branch
                return "b LU" + destinations[0]
            else
                # Conditional branch
                comp = "cmp " + val_to_arm(sources[0]) + ", 1\n"
                branches = "beq LU" + destinations[0] + "\nbne LU" + destinations[1]
                return comp + branches
            end
        else if (instruction_type == "add" || instruction_type == "mul" || instruction_type == "sub" || instruction_type == "and")
            return do_arithmatic_and_boolean(instruction_type)
        else if instruction_type == "or"
            return do_arithmatic_and_boolean("orr")
        else if instruction_type == "xor"
            return do_arithmatic_and_boolean("eor")
        else if instruction_type == "mov"
            return "mov " + val_to_arm(destinations[0]) + ", " + val_to_arm(sources[0])
        else if instruction_type == "sdiv"
            #TODO
        else if instruction_type == "Return"
            #TODO
            if sources == []
                return "ret void"
            else
                return "ret " + typ + " " + val_to_llvm(sources [0])
            end
        else if instruction_type == "Comparison"
            #TODO
            setup = "mov " + val_to_arm(destinations[0]) + ", #0\n"
            compare = "cmp " + val_to_arm(sources[1]) + ", " + val_to_arm(sources[2]) + "\n"
            move = ""
            if sources[0] == "eq"
              move = "moveq " + val_to_arm(desitinations[0]) + ", #1"
            else if sources [0] == "ne"
              move = "movne " + val_to_arm(desitinations[0]) + ", #1"
            else if sources [0] == "sgt"
              move = "movgt " + val_to_arm(desitinations[0]) + ", #1"
            else if sources [0] == "sge"
              move = "movge " + val_to_arm(desitinations[0]) + ", #1"
            else if sources [0] == "slt"
              move = "movlt " + val_to_arm(desitinations[0]) + ", #1"
            else if sources [0] == "sle"
              move = "movle " + val_to_arm(desitinations[0]) + ", #1"
            end
            return setup + compare + move
            return val_to_llvm(destinations [0]) + " = " + "icmp " + sources [0] + " " + typ + " " + val_to_llvm(sources [1]) + ", " + val_to_llvm(sources [2])
        else if instruction_type == "Allocation"
            #TODO
            return val_to_llvm(destinations [0]) + " = alloca " + typ
        else if instruction_type == "bitcast" || instruction_type == "trunc" || instruction_type == "zext"
            return "mov " + val_to_arm(destinations[0]) + ", " + val_to_arm(sources[0])
        else if instruction_type == "Load"
            #TODO
            return val_to_llvm(destinations [0]) + " = load " + typ + ", " + typ + "* " + val_to_llvm(sources [0])
        else if instruction_type == "Store"
            #TODO
            return "store " + typ + " " + val_to_llvm(sources [0]) + ", " + typ + "* " + val_to_llvm(destinations [0])
        else if instruction_type == "GetElement"
            #TODO
            return "add " + val_to_arm(destinations[0]) + ", " + val_to_arm(sources[0]) + ", #8"
            return val_to_llvm(destinations [0]) + " = getelementptr " + typ.llvm_no_pointer() + ", " + typ + " " + val_to_llvm(sources [0]) + ", i1 0, i32 " + val_to_llvm(sources [1])
        # Needs to be resoved
        else if instruction_type == "NegateInteger"
            if sources[0].type == "Integer" && sources[0] > MAX_THAT_CAN_FIT_IN_OP_TWO
                # Constant that is too big
                ld_constant = "movw " + val_to_arm(scratch_register[0]) + ", \#:lower16: "+ val_to_arm(sources[0]) +"\n"
                ld_constant = ld_constant + "movt " + val_to_arm(scratch_register[0]) + ", \#:upper16: " + val_to_arm(sources[0]) + "\n"
                ld_zero = "mov " + val_to_arm(scratch_register[1]) + ", 0\n"
                sub = "sub " + val_to_arm(destinations[0]) + ", " + val_to_arm(scratch_registers[1]) +", " + val_to_arm(scratch_register[0])
            else
                ld_zero = "mov " + scratch_register[0] + ", 0\n"
                sub = "sub " + val_to_arm(destinations[0]) + ", " +  scratch_register[0] + ", " + val_to_arm(sources[0])
                return ld_zero + sub
            end
        else if instruction_type == "NegateBoolean"
            #TODO
            # Negate by XORing with 1
            val_to_llvm(destinations[0]) + " = xor i32 1, " + val_to_llvm(sources[0])
        else if instruction_type == "FunctionCall"
            args = sources.slice(1, sources.length())
            instr = ""
            #TODO
            
            instr = instr + "call " + typ + " @" + sources[0] + "("
            for i = 1; i < sources.length(); i = i + 2
                if i != 1
                    instr = instr + ", "
                end
                instr = instr + val_to_arm(sources [i]) + " " + val_to_arm(sources [i + 1])
            end
            instr = instr + ")"
            if destinations != []
                # If a result is expected, move the result from r0 into the destination register
                instr = instr + "\n" + "mov " + val_to_arm(destinations[0]) + ", r0 ; Store the result"
            end
            return instr
        else if instruction_type == "Phi"
            throw "Phi instructions should not be emitted for ARM"
        else
            throw InstructionError("Unknown instruction type " + instruction_type)
        end
    end

    :do_arithmatic_and_boolean (instruction_code)
        if sources[0].type == "Integer"
            # Constant that is too big
            ld_constant = "movw " + val_to_arm(scratch_registers[0]) + ", \#:lower16: "+ val_to_arm(sources[0]) +"\n"
            ld_constant = ld_constant + "movt " + val_to_arm(scratch_registers[0]) + ", \#:upper16: " + val_to_arm(sources[0]) + "\n"
            return ld_constant + instruction_code + " " + val_to_arm(destinations[0]) + ", " + val_to_arm(scratch_registers[0]) + ", " + val_to_arm(sources[1])
        else if sources [1].type == "Integer" && ((sources[1] > MAX_THAT_CAN_FIT_IN_OP_TWO) || instruction_type == "mul")
        # Constant that is too big
            ld_constant = "movw " + val_to_arm(scratch_registers[0]) + ", \#:lower16: "+ val_to_arm(sources[1]) +"\n"
            ld_constant = ld_constant + "movt " + val_to_arm(scratch_registers[0]) + ", \#:upper16: " + val_to_arm(sources[1]) + "\n"
            return ld_constant + instruction_code + " " + val_to_arm(destinations[0]) + ", " + val_to_arm(sources[0]) + ", " + val_to_arm(scratch_registers[0])
        end
        return instruction_code + " " + val_to_arm(destinations[0]) + ", " + val_to_arm(sources[0]) + ", " + val_to_arm(sources [1])
    end

end
