require register
require arm_instruction
constructor InstructionError(message)
    :show
        message
    end
end

MAX_THAT_CAN_FIT_IN_OP_TWO = (2 ** 9) - 1
constructor Instruction(instruction_type, sources, destinations, typ)

    if sources.type == "Array"
        for i = 0; i < sources.length!(); i++
            if sources[i].type == "VirtualRegister"
                sources[i].add_use(this)
            end
        end
    end
    
    if destinations.type == "Array"
        for i = 0; i < destinations.length!(); i++
            if destinations[i].type == "VirtualRegister"
                destinations[i].add_source(this)
            end
        end
    else if destinations.type == "VirtualRegister"
        destinations.add_source(this)
    end

    :show
        "<" + instruction_type + " from " + sources + " to " + destinations + ">"
    end

    :copy
        this
    end

    :val_to_llvm(val)
        if val.type == "Integer" || val.type == "String"
            val
        else if val.type == "CFGNode"
            val.text_label
        else
            val.emit_llvm()
        end
    end

    :val_to_arm(val)
        if val.type == "Integer" || val.type == "String"
            val
        else
            val.emit_arm()
        end
    end

    :emit_llvm
        # "Label", label_name
        if instruction_type == "Label"
            return "LU" + sources + ":"
        else if instruction_type == "Branch"
            if sources == []
                # Unconditional branch
                return "br label %LU" + destinations[0]
            else
                # Conditional branch
                return "br i1 " + val_to_llvm(sources[0]) + ", label %LU" + destinations[0] + ", label %LU" + destinations[1]
            end
        else if instruction_type == "add" || instruction_type == "mul" || instruction_type == "sdiv" || instruction_type == "sub" || instruction_type == "and" || instruction_type == "or" || instruction_type == "xor"
            # Arithmatic and Boolean instructions
            return val_to_llvm(destinations [0]) + " = " + instruction_type + " " + typ + " " + val_to_llvm(sources [0]) + ", " + val_to_llvm(sources [1])
        else if instruction_type == "Return"
            if sources == []
                return "ret void"
            else
                return "ret " + typ + " " + val_to_llvm(sources [0])
            end
        else if instruction_type == "Comparison"
            return val_to_llvm(destinations [0]) + " = " + "icmp " + sources [0] + " " + typ + " " + val_to_llvm(sources [1]) + ", " + val_to_llvm(sources [2])
        else if instruction_type == "Allocation"
            return val_to_llvm(destinations [0]) + " = alloca " + typ
        else if instruction_type == "bitcast" || instruction_type == "trunc" || instruction_type == "zext"
            return val_to_llvm(destinations [0]) + " = " + instruction_type + " " + typ + " " + val_to_llvm(sources [0]) + " to " + sources [1]
        else if instruction_type == "Load"
            return val_to_llvm(destinations [0]) + " = load " + typ + ", " + typ + "* " + val_to_llvm(sources [0])
        else if instruction_type == "Store"
            return "store " + typ + " " + val_to_llvm(sources [0]) + ", " + typ + "* " + val_to_llvm(destinations [0])
        else if instruction_type == "GetElement"
            return val_to_llvm(destinations [0]) + " = getelementptr " + typ.llvm_no_pointer() + ", " + typ + " " + val_to_llvm(sources [0]) + ", i1 0, i32 " + val_to_llvm(sources [1])
        # Needs to be resoved
        else if instruction_type == "NegateInteger"
            val_to_llvm(destinations[0]) + " = sub i32 0, " + val_to_llvm(sources[0])
        else if instruction_type == "NegateBoolean"
            # Negate by XORing with 1
            val_to_llvm(destinations[0]) + " = xor i32 1, " + val_to_llvm(sources[0])
        else if instruction_type == "FunctionCall"
            if destinations != []
                llvm = val_to_llvm(destinations[0]) + " = "
            else
                llvm = ""
            end
            llvm = llvm + "call " + typ + " @" + sources[0] + "("
            for i = 1; i < sources.length(); i = i + 2
                if i != 1
                    llvm = llvm + ", "
                end
                llvm = llvm + val_to_llvm(sources [i]) + " " + val_to_llvm(sources [i + 1])
            end
            llvm = llvm + ")"
            return llvm
        else if instruction_type == "Phi"
            llvm = val_to_llvm(destinations[0]) + " = phi " + typ
            for i = 0; i < sources.length(); i = i + 2
                if i != 0
                    llvm = llvm + ","
                end
                llvm = llvm + " [ " + val_to_llvm(sources[i]) + ", %" + val_to_llvm(sources[i+1]) + " ]"
            end
            return llvm
        else
            throw InstructionError("Unknown instruction type " + instruction_type)
        end
    end
    
    # Returns an array of ARMInstructions
    :translate_to_arm
        # "Label", label_name
        if instruction_type == "Label"
            result = []
            return result
        else if instruction_type == "mov"
            result = [ARMInstruction("mov", sources, destinations)]
            return result
        else if instruction_type == "Branch"
            if sources == []
                # Unconditional branch
                return [ARMInstruction("b", sources, destinations)]
            else
                # Conditional branch
                # Compare then branch if equal or branch if not equal
                result = []
                result.add!(ARMInstruction("cmp", [sources[0], 1], []))
                result.add!(ARMInstruction("beq", [], [destinations[0]]))
                result.add!(ARMInstruction("bne", [], [destinations[1]]))
                return result
            end
        else if (instruction_type == "add" || instruction_type == "mul" || instruction_type == "sub" || instruction_type == "and")
            return do_arithmatic_and_boolean(instruction_type)
        else if instruction_type == "or"
            return do_arithmatic_and_boolean("orr")
        else if instruction_type == "xor"
            return do_arithmatic_and_boolean("eor")
        else if instruction_type == "sdiv"
            #TODO
            result = []
            return result
        else if instruction_type == "Return"
            result = []
            return result
            #TODO
            if sources == []
                return "ret void"
            else
                return "ret " + typ + " " + val_to_llvm(sources [0])
            end
        else if instruction_type == "Comparison"
            #TODO
            return generate_compare_instruction(instruction_type)
            setup = "mov " + val_to_arm(destinations[0]) + ", #0\n"
            compare = "cmp " + val_to_arm(sources[1]) + ", " + val_to_arm(sources[2]) + "\n"
            move = ""
            if sources[0] == "eq"
              move = "moveq " + val_to_arm(desitinations[0]) + ", #1"
            else if sources [0] == "ne"
              move = "movne " + val_to_arm(desitinations[0]) + ", #1"
            else if sources [0] == "sgt"
              move = "movgt " + val_to_arm(desitinations[0]) + ", #1"
            else if sources [0] == "sge"
              move = "movge " + val_to_arm(desitinations[0]) + ", #1"
            else if sources [0] == "slt"
              move = "movlt " + val_to_arm(desitinations[0]) + ", #1"
            else if sources [0] == "sle"
              move = "movle " + val_to_arm(desitinations[0]) + ", #1"
            end
            return setup + compare + move
            return val_to_llvm(destinations [0]) + " = " + "icmp " + sources [0] + " " + typ + " " + val_to_llvm(sources [1]) + ", " + val_to_llvm(sources [2])
        else if instruction_type == "Allocation"
            #TODO
            result = []
            return result
            return val_to_llvm(destinations [0]) + " = alloca " + typ
        else if instruction_type == "bitcast" || instruction_type == "trunc" || instruction_type == "zext"
            result = []
            return result
            return "mov " + val_to_arm(destinations[0]) + ", " + val_to_arm(sources[0])
        else if instruction_type == "Load"
            #TODO
            result = []
            return result
            return val_to_llvm(destinations [0]) + " = load " + typ + ", " + typ + "* " + val_to_llvm(sources [0])
        else if instruction_type == "Store"
            #TODO
            result = []
            return result
            return "store " + typ + " " + val_to_llvm(sources [0]) + ", " + typ + "* " + val_to_llvm(destinations [0])
        else if instruction_type == "GetElement"
            #TODO
            result = []
            return result
            return "add " + val_to_arm(destinations[0]) + ", " + val_to_arm(sources[0]) + ", #8"
            return val_to_llvm(destinations [0]) + " = getelementptr " + typ.llvm_no_pointer() + ", " + typ + " " + val_to_llvm(sources [0]) + ", i1 0, i32 " + val_to_llvm(sources [1])
        # Needs to be resoved
        else if instruction_type == "NegateInteger"
            result = []
            return result
            if sources[0].type == "Integer" && sources[0] > MAX_THAT_CAN_FIT_IN_OP_TWO
                # Constant that is too big
                ld_constant = "movw " + val_to_arm(scratch_register[0]) + ", \#:lower16: "+ val_to_arm(sources[0]) +"\n"
                ld_constant = ld_constant + "movt " + val_to_arm(scratch_register[0]) + ", \#:upper16: " + val_to_arm(sources[0]) + "\n"
                ld_zero = "mov " + val_to_arm(scratch_register[1]) + ", 0\n"
                sub = "sub " + val_to_arm(destinations[0]) + ", " + val_to_arm(scratch_registers[1]) +", " + val_to_arm(scratch_register[0])
            else
                ld_zero = "mov " + scratch_register[0] + ", 0\n"
                sub = "sub " + val_to_arm(destinations[0]) + ", " +  scratch_register[0] + ", " + val_to_arm(sources[0])
                return ld_zero + sub
            end
        else if instruction_type == "NegateBoolean"
            #TODO
            # Negate by XORing with 1
            result = []
            return arr
            val_to_llvm(destinations[0]) + " = xor i32 1, " + val_to_llvm(sources[0])
        else if instruction_type == "FunctionCall"
            args = sources.slice(1, sources.length())
            instr = ""
            #TODO
            result = []
            return result
            
            instr = instr + "call " + typ + " @" + sources[0] + "("
            for i = 1; i < sources.length(); i = i + 2
                if i != 1
                    instr = instr + ", "
                end
                instr = instr + val_to_arm(sources [i]) + " " + val_to_arm(sources [i + 1])
            end
            instr = instr + ")"
            if destinations != []
                # If a result is expected, move the result from r0 into the destination register
                instr = instr + "\n" + "mov " + val_to_arm(destinations[0]) + ", r0 ; Store the result"
            end
            return instr
        else if instruction_type == "Phi"
            throw "Phi instructions should not be emitted for ARM"
        else
            throw InstructionError("Unknown instruction type " + instruction_type)
        end
    end

    :do_arithmatic_and_boolean (instruction_code)
        result = []
        return result
        if sources[0].type == "Integer"
            # Constant that is too big
            scratch_one = VirtualRegister()
            result.append!(ARMInstruction("movw", [scratch_one], []))
            ld_constant = "movw " + val_to_arm(scratch_registers[0]) + ", \#:lower16: "+ val_to_arm(sources[0]) +"\n"
            ld_constant = ld_constant + "movt " + val_to_arm(scratch_registers[0]) + ", \#:upper16: " + val_to_arm(sources[0]) + "\n"
            return ld_constant + instruction_code + " " + val_to_arm(destinations[0]) + ", " + val_to_arm(scratch_registers[0]) + ", " + val_to_arm(sources[1])
        else if sources [1].type == "Integer" && ((sources[1] > MAX_THAT_CAN_FIT_IN_OP_TWO) || instruction_type == "mul")
        # Constant that is too big
            ld_constant = "movw " + val_to_arm(scratch_registers[0]) + ", \#:lower16: "+ val_to_arm(sources[1]) +"\n"
            ld_constant = ld_constant + "movt " + val_to_arm(scratch_registers[0]) + ", \#:upper16: " + val_to_arm(sources[1]) + "\n"
            return ld_constant + instruction_code + " " + val_to_arm(destinations[0]) + ", " + val_to_arm(sources[0]) + ", " + val_to_arm(scratch_registers[0])
        end
        return instruction_code + " " + val_to_arm(destinations[0]) + ", " + val_to_arm(sources[0]) + ", " + val_to_arm(sources [1])
    end

 :generate_compare_instruction(type)
        result = []
        return result
        default_value = "\#0"
        if type == "<=" || type == ">="
            default_value = "\#1"
        end
        result = "mov " + val_to_arm(destinations[0]) + ", " + default_value + "\n"
        result = result + "cmp " + val_to_arm(sources[0]) + ", " + val_to_arm(sources[1]) + " ; Compare\n"
        if type == "<="
            # Check the opposite and set the result to 0 if it is true
            result = result + "mov "
        else if type == ">="

        else if type == "<"

        else if type == "=="

        else if type == "!="

        else if type == ">"

        end
    end


end
