require ast_factory
require ../types/primitive_type
require ../instructions/instruction
require ../instructions/register

constructor BinaryNode(operator, left, right, line)
    statement? = false
    expression? = true
    :show
        "<" + operator + " " + left + " " + right + ">"
    end

    :check_both_types(l, r, typ)
        if l.can_not_become(typ)
            print("Type error on line "+line+" left side of " + operator + " was not a(n) "+typ)
            return primitive_type("error")
        else if r.can_not_become(typ)
            print("Type error on line "+line+" right side of " + operator + " was not a(n) "+typ)
            return primitive_type("error")
        end
        return typ
    end

    :typecheck(symbol_table, struct_map)
        left_type = left.typecheck(symbol_table, struct_map)
        right_type = right.typecheck(symbol_table, struct_map)
        if operator == "+" || operator == "*" || operator == "-" || operator == "/"
            return check_both_types(left_type, right_type, primitive_type("int"))
        else if operator == "||" || operator == "&&"
            return check_both_types(left_type, right_type, primitive_type("bool"))
        else if operator == "==" || operator == "!="
            if left_type.can_not_become(right_type)
                print("Type error on line "+line+" left side of comparison was " + left_type + " while right side was " + right_type)
                return primitive_type("error")
            else
                return primitive_type("bool")
            end
        else if operator == "<=" || operator == ">=" || operator == "<" || operator == ">"
            if left_type.can_not_become(primitive_type("int"))
                print("Type error on line "+line+" left side of " + operator + " was not an int")
                return primitive_type("error")
            else if right_type.can_not_become(primitive_type("int"))
                print("Type error on line "+line+" right side of " + operator + " was not an int")
                return primitive_type("error")
            else
                return primitive_type("bool")
            end
        end 

    end

    binary_op_to_instruction_op = {}
    binary_op_to_instruction_op["+"] = "Add"
    binary_op_to_instruction_op["-"] = "Subtract"
    binary_op_to_instruction_op["*"] = "Multiply"
    binary_op_to_instruction_op["/"] = "Divide"
    binary_op_to_instruction_op["||"] = "LogicalOr"
    binary_op_to_instruction_op["&&"] = "LogicalAnd"
    binary_op_to_instruction_op["=="] = "Equal"
    binary_op_to_instruction_op["<="] = "LessThanOrEqual"
    binary_op_to_instruction_op[">="] = "GreaterThanOrEqual"
    binary_op_to_instruction_op["!="] = "NotEqual"
    binary_op_to_instruction_op["<"] = "LessThan"
    binary_op_to_instruction_op[">"] = "GreaterThan"

    binary_op_to_instruction_short = {}
    binary_op_to_instruction_short["+"] = (x, y -> x + y)
    binary_op_to_instruction_short["-"] = (x, y -> x - y)
    binary_op_to_instruction_short["*"] = (x, y -> x * y)

    # WARNING. THIS CURRENTLY RETURNS A FLOAT. NEED TO FIX SO THAT IT RETURNS AN INT
    binary_op_to_instruction_short["/"] = (x, y -> (x / y).floor())
    binary_op_to_instruction_short["||"] = (x, y -> x ^ y)
    binary_op_to_instruction_short["&&"] = (x, y -> x & y)
    binary_op_to_instruction_short["=="] = (x, y -> x == y)
    binary_op_to_instruction_short["<="] = (x, y -> x <= y)
    binary_op_to_instruction_short[">="] = (x, y -> x >= y)
    binary_op_to_instruction_short["!="] = (x, y -> x != y)
    binary_op_to_instruction_short["<"] = (x, y -> x < y)
    binary_op_to_instruction_short[">"] = (x, y -> x > y)

    :translate(current_block)
        t_left = left.translate(current_block)
        t_right = right.translate(current_block)
        if t_left.type == "Integer" && t_right.type == "Integer"
            return binary_op_to_instruction_short[operator](t_left, t_right)
        end
        result_register = VirtualRegister("i32")
        current_block.add_instruction(binary_op_to_instruction_op[operator], [t_left, t_right], [result_register])
        return result_register
    end

end

:parse_binary_node(json)
    lft = create_node!(json["lft"])
    right = create_node!(json["rht"])
    BinaryNode!(json["operator"], lft, right, json["line"])
end